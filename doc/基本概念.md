# 术语统一

![](page-and-module.png)

- 页面与模块。一个比较典型的业务模块是素材中心, 页面是模块的容器，根据菜单配置为模块提供入口
- 通用组件 → 业务无关的组件
- 业务组件 → 和具体模块关联的，它不应该放到 common，它属于具体业务模块，但又可能共享给其他模块。
- common 模块之间共享的基础设施，不属于具体模块
- register 模块注册目录，在这里统一暴露模块的公开接口

<br>
<br>

# 未来架构设想

![](arch.png)

- 最小粒度不是页面，而是业务模块。举个例子，具体的业态可以是一个业务模块，例如康养；一个通用的服务，也是一个业务模块，例如素材中心、大会员
- 页面将成为一个通用的容器/基座，只有通用的基础业务逻辑，例如登录、当前应用、必要的全局状态。在技术实现上只有一个页面，页面具体展示什么由菜单权限配置决定。
- 业务模块和页面模块不耦合。一个业务模块可能在多个页面存在，比如素材中心可能在多个页面存在，康养模块的活动、项目散落在不同的页面中。
- 插件中心。因为模块脱离的页面，所以不应该跟随页面进行编译。那么业务模块应该如何引入呢？我的设想是按照类似插件的形式按需注入，比如我们可以去解析后端返回的菜单配置，得到需要注入的插件，加载进来便可。

  这里还有额外的工作是模块与模块的依赖(依赖注入)、版本管理，加载优化、本地开发调试等问题。

- 参考案例：小程序插件

<br>
<br>

# 从区分模块和页面开始

对于模块隔离与共享。我还是比较推荐物理的隔离，或者说模块之间必须有明确的边界。

- 基于未来的架构考虑
- 对于共享的东西放在模块的 shared 目录下(目录即文档，目录自身包含语义非常重要，相比使用文档去说明，如果目录本身有意义，可以自然形成一种约定)，然后在 common 重新导出。
- 而不是所有东西都堆砌在 common 中，当 common 变得越来越臃肿后，模块的边界就会越来越模糊，无法追溯来源。
- 这种概念类似于微服务，有明显的边界，暴露有限的接口。可以使用 ESlint 来对这种规范进行强约束.
- 思考的空间，在某种意义上，显式的约束是一件好事。Java 中的包、类，实际上就是一个封装单元，没有 JavaScript 那么随意，你要暴露给外部的内容必须要显式声明公开，这其实就给开发者一个思考的空间：我应不应该公开这个接口？主动考虑别人会怎么用，反过来优化自己的设计，三思而后行。
- common 在这里就相当于一个公开 API 注册的服务。按照架构的设想，这以后有可能是以一个插件中心的形式存在。
- 小程序的插件设计。
- 通常业务模块可以共享出去的内容有 API、常量、业务组件(比如大会员后续会暴露出去的等级选择器、积分规则选择器等等)、mixin 等等

  目录结构示例:

  ```bash
  /common       # 共享的基础设施
  /register     # 注册器，模块的公开入口统一在这里进行注册
    member.js
  /dss-member    # 传统的页面
  /mod-member    # 模块，以 mod- 为前缀
    /shared      # 业务模块的公开接口, 具体实现都在 src 中，这里只是筛选要公开哪些东西。后面这个模块可能以库的形式编译
      api.js     # 使用 命名模块导出，这有利于体积优化
      components.js
      constants.js
      route.js
      mixins.js
      services.js # 共享的业务逻辑
    /src        # 私有源代码
      /views
      /components
      /constants
      /route
      ...
    package.json # 模块配置
  ```

